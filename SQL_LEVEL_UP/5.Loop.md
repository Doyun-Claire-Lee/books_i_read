# 반복문

## 반복문 의존증
 - SQL은 의도적으로 반복문을 설계에서 제외하였음.
 > 관계 조작은 관계 전체를 모두 조작의 대상으로 삼는다. 이러한 것의 목적은 반복을 제외하는 것이다. 최종 사용자의 새ㅑㅇ산성을 생각하면 이러한 조건을 만족해야 한다. 그래야만 응용 프로그래머의 생산성에도 기여할 수 있을 것이다.

1. 반복계의 단점
 - 성능: 반복계의 처리 시간은 '처리 횟수' * '한 회에 걸리는 처리 시간'이다.
 - SQL 실행의 오버 헤드: 
    - 전처리: SQL 구문을 네트워크로 전송 -> 데이터베이스 연결 -> SQL 구문 파스 -> SQL 구문의 실행 계획 생성 또는 평가
    - 후처리: 결과 집합을 네트워트로 전송
    - 오버헤드 중에서 가장 영향이 큰 것은 SQL 파스(구문 분석)이다.
 - 병렬 분산이 힘듦
    - 반복계는 반복 1회마다의 처리를 굉장히 단순화하므로 리소스를 분산해서 병렬 처리하는 최적화가어려움.
 - 데이터베이스의 진화로 인한 혜택을 받을 수 없음
   - DBMS의 버전이 오를수록 옵티마이저는 보다 효율적으로 실행 계획을 세우며, 데이터에 고속으로 접근할 수 있는 아키텍처를 구현
   - 이 모든 노력의 중심은 대규모 대이터를 다루는 '복잡한 SQL 구문'을 빠르게 하려는 데 있지 단순 SQL 구문과 같은 가벼운 처리를 빠르게 만드는 데 있지 않음.
 - 느린 구문을 튜닝할 수 있는 가능성도 거의 없음
2. 반복계를 빠르게 만드는 방법은 없을까? 
 - 반복계를 포장계로 다시 작성
 - 각각의 SQL을 빠르게 수정
 - 다중화 처리
   - CPU, 디스크 등 리소스에 여유가 있고, 처리를 나눌 수 있는 키가 명확하게 정해져 있을 경우'
   - 명확한 키가 없거나, 순서가 중요한 처리, 병렬화했을때 물리 리소스가 부족한 경우에는 사용할 수 없음.
3. 반복계의 장점
 - 실행 계획의 안정성: 실헹 계획이 단순하다는 것은 변동 위험이 거의 없다는 것을 의미
 - 예상 처리 시간의 정밀도
 - 트랜잭션 제어의 편리

## SQL에서는 반복을 어떻게 표현할까?
1. CASE 식과 윈도우 함수  
 - 절차 지향형 언어에서 반복의 내부에 대부분 IF 조건문을 세트로 사용하는 것처럼, SQL에서도 CASE 식과 윈도우 함수를 함께 세트로 사용함
 - MAX(__) OVER (PARTIRION BY __ ORDER BY __ ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
 - 대상 범위의 레코드를 직전의 1개로 제한
2. 최대 반복 횟수가 정해진 경우
 - 반복 횟수만큼 CASE 문의 조건으로 분기하여 해결
3. 반복 횟수가 정해지지 않은 경우
 - 인접 리스트 모델과 재귀 쿼리
    - 포인터 체인: 변경되는 데이터를 키로 삼아 데이터를 줄줄이 연결한 것
    - 인접 리스트 모델: 포인터 체인을 사용하는 테이블 형식
    - SQL에서 계층 구조를 찾는 방법 중 하나는 재귀 공통 테이블 식(recursion common table expression) 
 - 중첩 집합 모델: SQL에서 계층 구조를 나타내는 방법
   1. 인접 리스트 모델
   2. 중첩 집합 모델: 각 레코드의 데이터를 집합으로 보고, 계층구조를 집합의 중첩 관계로 나타내는 것
   3. 경로 열거 모델