# DBMS 아키텍처

### DBMS 아키텍처 개요
1. 쿼리 평가 엔진
   - 사용자로부터 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정(실행 계획)
   - 계획을 세우고 실행하는 DMBS의 핵심 기능을 담당하는 모듈
   
2. 버퍼 매니저
   - 버퍼라는 특별한 용도로 사용하는 메모리 영역을 관리하는 것
   - 디스크 용량 매니저와 함꼐 연동되어 작동

3. 디스크 용량 매니저
   - 어디에 어떻게 데이터를 저장할지를 관리하며, 데이터의 읽고 쓰기를 제어

4. 트랜잭션 매니저와 락 매니저
   - 동시에 데이터베이스에 접근해서 사용할 때, 각각의 처리(트랜잭션)의 정합성을 유지하고,
   - 필요한 경우 데이터에 락을 걸어 다른 사용자의 요청을 대기시킴

5. 리커버리 매니저
   - 데이터를 정기적으로 백업하고, 문제가 일어났을 때 복구하는 기능을 수행

> 성능이라는 관점에서 가장 중요한 것은 '쿼리 평가 엔진(실행 계획)'이다.


### DBMS와 버퍼

- 메모리는 한정된 희소자원 이지만 데이터베이스가 메모리에 저장하고자 하는 데이터는 굉장히 많다. 
- 데이터를 버퍼에 어떤 식으로 확보할지와 관련해 트레이드오프가 발생하게 된다.

1. 기억장치의 계층과 트레이드오프
   - 일반적으로 기억장치는 기억 비용에 따라 1차(레지스터, 메모리), 2차(HDD, CD, DVD, 플래시메모리), 3차(테이프 등)로 나뉜다.
   - 1차에서 3차로 갈 수록 같은 비용으로 저장할 수 있는 데이터 용량이 많아진다.
   - 1차에서 3차로 갈 수록 데이터 접근 속도가 저하된다.
   - 따라서 많은 데이터를 영속적으로 저장하려 하면 속도를 잃고, 속도를 얻고자 하면 많은 데이터를 영속적으로 저장하기 힘들다는 트레이드오프가 발생한다.

2. DBMS와 기억장치의 관계
    - 하드디스크(HDD): 현재 DBMS가 대부분의 데이터를 저장하는 매체
    - 메모리: 버퍼와 캐시를 활용한 속도 향상에 이용되는 저장 매체
   
3. 메모리 위에 있는 두 개의 버퍼: 데이터 캐시, 로그 버퍼
   - 데이터 캐시: 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 영역
   - 로그 버퍼: 갱신 요청을 받는 경우 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경을 수행
   - 데이터베이스의 갱신 처리는 구문 실행 시점과 저장소에 갱신하는 시점에 차이가 있는 비동기 처리
   
4. 메모리의 성질이 초래하는 트레이드오프
   - 휘발성: 하드웨어의 전원을 꺼버리면 메모리상의 모든 데이터가 사라진다. 따라서 미래에 메모리 가격이 낮아진다 해도, 영속성이 없는 이상 기능적으로 디스크를 완전히 대체하는 것은 불가능하다.
   - 휘발성의 문제점: 장애가 발생했을 때 메모리에 있던 데이터가 모두 사라져 데이터 부정합을 발생시키는 것
     - 데이터 캐시: 원본 데이터는 디스크 위에 남아있으므로 아무 문제 없다.
     - 로그 버퍼: 커밋 시점에 반드시 갱신 정보를 로그 파일에 씀으로써, 장애가 발생해도 정합성을 유지할 수 있도록 한다.
       - 커밋 때는 반드시 디스크에 동기 접근이 일어나므로, 지연이 발생할 가능성이 있어 트레이드오프가 발생할 수 있다.
       - 데이터 정합성(디스크 동기 처리) <-> 성능

5. 시스템 특성에 따른 트레이드오프
   - 데이터 캐시와 로그 버퍼의 크기
     - 기본적으로 데이터 캐시에 비해 로그 버퍼의 초기값이 굉장히 작음.
     - 데이터베이스는 기본적으로 검색을 메인으로 처리한다고 가정하기 때문에, 갱신 처리에 값비싼 메모리를 많이 사용하는 것 보다 자주 검색하는 데이터를 캐시에 올려놓는 것이 유리하다는 점이 반영되었다.

6. 추가적인 메모리 영역 '워킹 메모리'
   - 정렬 또는 해시 관련 처리에 사용되는 작업용 영역
   - 정렬은 ORDER BY 구, 집합 연산, 윈도우 함수 등의 기능을 사용할 때 실행됨
   - 해시는 테이블 등의 결합에서 해시 결합이 사용되는 때 실행됨.
   - 워킹 메모리 영역은 사용이 종료되면 해제되는 임시 영역
   - 이 영역이 다루려는 데이터 양 보다 영역이 작아 부족해지는 경우가 생기면 대부분의 DBMS는 저장소를 사용하기 때문에, 스왑이 발생하여 성능적으로 이슈가 될 수 있다.

### DBMS와 실행 계획
- 사용자는 데이터가 있는 곳을 알 필요도 없고, 데이터에 접근하는 방법도 DBMS에 맡긴다.

1. 데이터에 접근하는 방법은 어떻게 결정할까?
   - 쿼리 -> [파서] -> 파스된 쿼리 -> [옵티마이저] -> 플랜 생성 -> 비용 평가 -> [카탈로그 매니저] -> 플랜 평가
   - 파서 : 사용자로부터 입력받은 SQL 구문을 분석(구문 오류 확인, 구문 정형화)
   - 옵티마이저: DMBS 두뇌의 핵심으로, 인덱스 유무/데이터 분산 또는 편향 정도/DBMS 내부 매개변수 등의 조건을 고려해 선택 가능한 많은 실행 계획을 작성하고, 이들의 비용을 연산하여 가장 낮은 비용을 가진 실행 계획을 선택함.
   - 카탈로그 매니저: 옵티마이저가 실행 계획을 세울 때 옵티마이저에 인덱스의 통계 정보를 제공

2. 옵티마이저와 통계 정보
   - 통계 부족으로 인해 옵티마이저는 최적의 플랜을 선택하지 못할 수도 있다.
   - 통계 정보
     - 각 테이블의 레코드 수
     - 각 테이블의 필드 수와 필드 크기
     - 필드의 카디널리티
     - 필드값의 히스토그램(어떤 값이 얼마나 분포되어 있는가)
     - 필드 내부에 있는 NULL 수
     - 인덱스 정보
   - 카탈로그 정보가 실제 테이블 또는 인덱스와 일치하지 않을 때 문제가 생기게 된다.

3. 최적의 실행 계획이 작성되게 하려면
   - 테이블의 데이터가 많이 바뀌면 카탈로그의 통계 정보도 함께 갱신해주어야 한다.
   - 통계 정보 갱신은 대상 테이블 또는 인덱스의 크기와 수에 따라서 몇십 분에서 몇 시간이 소요되기도 하는 실행 비용이 굉장히 높은 작업

### 실행 계획이 SQL 구문의 성능을 결정
- 최적의 경로가 설정되어 있는데도 느린 경우가 있다.
- 통계 정보가 최신이라도 SQL구문이 너무 복잡할 경우 옵티마이저가 최적의 접근 경로를 선택하지 못할 수도 있다.

  1. 실행 계획 확인 방법
     - Oracle : SET AUTOTRACE TRACEONLY
     
