# SQL의 순서

### 레코드에 순번 붙이기
1. 기본 키가 한 개의 필드일 경우 : 윈도우 함수(ROW_NUMBER)를 사용하여 순서를 붙인다.
2. 기본 키가 여러개의 필드로 구성되는 경우
   - 윈도우 함수 사용: ORDER BY에 여러개의 필드를 추가하기만 하면 됨
   - 서브쿼리 사용: 다중 필드 비교 
3. 그룹마다 순번을 붙이는 경우
   - 윈도우 함수 사용: ROW_NUMBER 함수와 PARTITION BY 구문을 함께 적용

### 레코드에 순번 붙이기 응용
1. 중앙값 구하기
   - 레코드의 개수가 홀수인 경우: 중앙의 값 그냥 사용
   - 레코드의 개수가 짝수인 경우: 중앙의 두 값의 평균값을 사용
   - 집합 지향적 방법: 상위집합과 하위집합을 이용하나 자기결합이 여러 번 발생하므로 비효율적
   - 절차 지향적 방법: 윈도우 함수를 이용하여 순번을 붙인 후 중앙값 찾기
2. 순번을 사용한 테이블 분할
   - 집합 지향적인 방법은 반드시 자기 결합을 사용한다.
3. 테이블에존재하는 시퀀스 구하기

### 시퀀스 객체, IDENTITY 필드, 채번 테이블
1. 시퀀스 객체
   - 테이블이나 뷰처럼 스키마 내부에 존재하는 객체
   - 시퀀스 객체의 문제점
     1. 표준화가 늦어 구현에 따라 구문이 달라 이식성이 없고, 사용할 수 없는 구현도 있다.
     2. 시스템에서 자동으로 생성되는 값이므로 실제 엔티티 속성이 아니다.
     3. 성능적인 문제를 일으킨다.
   - 시퀀스 객체로 발생하는 성능 문제
     - 시퀀스 객체의 특성: 유일성, 연속성, 순서성
     - 이러한 특성을 유지하기 위해 동시 실행 제어를 한다. (락 매커니즘) 
       - 동시에 여러 사용자가 접근하는 경우 락 충돌로 인해 성능 저하 가능성
       - 사용자가 연속적으로 시퀀스 객체를 사용하는 경우 오버헤드 발생 가능성
   - 시퀀스 성능 문제의 대처
     - CHACHE: 새로운 값이 필요할 때마다 메모리에 읽어들일 필요가 있는 값의 수를 설정하는 옵션으로 접근 비용을 줄일 수 있음.
     - NOORDER: 순서성을 담보하지 않아 오버헤드를 줄일 수 있음.
   - 순번을 키로 사용할 때의 성능 문제
     - 순번처럼 비슷한 데이터를 연속으로 적재하면 물리적으로 같은 영역에 저장되고, 저장소의 특정 물리적 블록에만 io부하가 커지므로 성능 악화가 발생함.
     - 이렇게 io 부하가 몰리는 부분을 핫 스팟 또는 핫 블록이라고 부른다.
     - 대표적인 예로 시퀀스 객체를 사용한 insert문을 반복하여 대량의 레코드를 생성하는 경우를 들 수 있다.
     - 성능 대처와 역 트레이드오프
       - oracle의 역 키 인덱스처럼, 연속된 값을 도입하는 경우라도 분산할 수 있는 구조(일종의 해시)를 사용하는 것 -> insert의 성능은 증가하나 select	의 성능은 나빠질 수 있음
       - 인덱스에 일부러 복잡한 필드를 추가하여 데이터의 분산도를 높이는 것 -> 논리적인 차원에서 좋은 설계가 아님
2. IDENTITY 필드
   - 자동 순번 필드
   - 기능적, 성능적 측면에서 모두 시퀀스 객체보다 심각한 문제를 가짐
   - 시퀀스 객체는 테이블과 독립적이므로 여러 테이블에서 사용할 수 있으나 IDENTITY 필드는 특정 테이블과 연결됨
   - 시퀀스 객체는 적어도 CACHE, NOORDER를 지정할 수 있지만 IDENTITY 필드는 제한적으로만 사용할 수 있음
3. 채번 테이블
   - 현재는 거의 사용하지 않는 방식(구시대의 유물..)
   - bottle neck이 걸려도 튜닝할 수 있는 방법이 전혀 없음
