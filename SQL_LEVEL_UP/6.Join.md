# 결합
## 기능적 관점으로 구분하는 결합의 종류

> 생성되는 결과의 형태에 따라 분류됨. 서로 배타적인 분류이므로 '내부 결합이면서 외부 결합이다'와 같은 조합은 없다.
> - 크로스 결합
> - 내부 결합
> - 외부 결합

> 결합 조건으로 등호(=)를 사용하는지, 부등호를 사용하는지에 따라 분류
> - 등가 결합
> - 비등가 결합

> 내부 결합이면서 등가 결합
> - 자연 결합

1. 크로스 결합 - 모든 결합의 모체
- 실무에서 사용하는 경우가 없음(크로스 결합의 결과가 필요한 경우가 없고, 비용이 매우 많이 드는 연산이기 때문)

2. 내부 결합 - 왜 '내부' 일까?
- 가장 많이 사용되는 조합 중 하나
- 내부 결합의 결과는 모두 크록스 결합의 일부(부분 집합)이기 때문에, '내부' 라는 용어를 사용
- 기본 키를 사용하여 내부 결합 결과와 똑같은 스칼라 서브쿼리를 구현할 수 있다.
- 내부 결합을 사용할 수 있는 경우 내부 결합을 사용하는 게 비용 면에서 유리하다.

3. 외부 결합 - 왜 '외부' 일까?
- 왼쪽 외부 결합, 오른쪽 외부 결합, 완전 외부 결합
- 마스터가 되는 테이블을 왼쪽에 적으면 왼쪽 외부 결합, 오른쪽에 적으면 오른쪽 외부 결합

4. 외부 결합과 내부 결합의 차이
- 외부 결합의 결과가 크로스 결합 결과의 부분 접합이 아닌 이유는, 외부 결합이 마스터 테이블의 정보를 모두 보존하고자 NULL을 생성하기 때문
- 크로스 결합과 내부 결합은 NULL을 생성하지 않음

5. 자기 결합
- 말 그대로 자기 자신과 결합하는 연산
- 생성되는 결과를 기준으로 분류하는 것이 아니라 연산의 대상으로 무엇을 사용하는지에 따른 분류
- 자기 결합을 수행하는 경우 일반적으로 같은 테이블에 별칭을 붙여 마치 다른 테이블인 것처럼 다룸.

## 결합 알고리즘과 성능

> 옵티마이저가 선택 가능한 알고리즘은 크게 다음과 같다.
> - Nested Loops : 가장 빈번하게 볼 수 있고, 각종 결합 알고리즘의 기본이 되는 알고리즘
> - Hash
> - Sort Merge

- 옵티마이저가 어떤 알고리즘을 선택할지의 여부는 데이터 크기 또는 결합 키의 분산 요인에 의존한다.

1. Nested Loop
- 이름 그대로 중첩 반복을 사용하는 알고리즘
- 결합은 한번에 두 개의 테이블만 결합하므로 본질적으로 이중 반복과 같은 의미
- 결합 대상 테이블(구동 테이블, 외부 테이블)에서 레코드를 하나씩 반복해가며 스캔 후, 구동 테이블의 레코드 하나마다 다른 테이블(내부 테이블)이 레코드를 하나씩 스캔해서 결합 조건에 맞으면 리턴한다.
- 구동 테이블이 무엇이든 간에 접근하는 레코드 수는 변하지 않지만, 실제로 구동 테이블의 선택은 성능에서 굉장히 중요한 의미를 가짐.
- 구체적으로는, 구동 테이블이 작을수록 성능이 좋아짐.(내부 테이블의 결합 키 필드에 인덱스가 존재하는 경우)
- 결합 키로 내부테이블에 접근 할 때 히트되는 레코드가 너무 많으면 기대만큼의 성능이 나오지 않기도 함. 이럴땐 역설적으로 구동 테이블로 큰 테이블을 선택하여 극단적으로 성능이 저하되는 것을 방지할 수 있음.

2. Hash
- 입력에 대해 어느정도 유일성과 균일성을 가진 값을 출력하는 함수를 해시라고 함.
- 해시 결합은 일단 작은 테이블을 스캔하고, 결합 키에 해시 함수를 적용해서 해시값으로 변환한 후 큰 테이블을 스캔하여 결합 키가 해시값에 존재하는지를 확인하는 방법으로 결합 수행
- 해시 테이블은 DBMS의 워킹 메모리에 저장되므로 작은 테이블에서 해시 테이블을 만드는 것이 조금이라도 더 효율적임.
- 따라서 Nested Loops에 비해 메모리를 크게 소모함.
- 메모리가 부족해지면 저장소를 사용하게 되므로 지연이 발생할 수 있음.
- 출력되는 해시값은 입력값의 순서를 알지 못하므로, 동치 결합에만 사용 가능
- Hash가 유용한 경우
  - Nested Loops에서 적절한 구동테이블(상대적으로 충분히 작은 테이블)이 존재하지 않는 경우, 내부 테이블에서 히트되는 레코드 수가 너무 많은 경우, 내부 테이블에 인덱스가 존재하지 않는 경우
  - Nested Loops가 효율적으로 작동하지 않는 경우의 차선책
- Hash 결합은 반드시 양쪽 테이블의 레코드를 전부 읽어야 하므로, 테이블 풀 스캔이 사용되는 경우가 많음.

3. Sort Merge
- Merge, Merge Join이라 부르기도 함.
- 결합 대상 테이블들을 각각 결합 키로 정렬하고, 일치하는 결합 키를 찾으면 결합하는 방식
- 대상 테이블을 모두 정렬해야 하므로 Nested Loops 보다 많은 메모리를 소비
- 동치 결합 뿐만 아니라 부등호를 사용한 결합에도 사용 가능, 부정 조건(<>) 결합은 사용 불가
- 테이블을 정렬하므로 한쪽 테이블을 모두 스캔한 시점에 결합을 완료할 수 있음.
- 테이블 정렬을 생략할 수 있는 상당히 예외적인 경우에는 고려해 볼 수 있음.

## 결합이 느리다면

1. 상황에 따른 최적의 결합 알고리즘
- 옵티마이저는 각 결합 방식의 장점과 단점을 생각하며 알고리즘을 선택하지만, 여러 이유로 최적의 결합 알고리즘을 선택하지 못할 수 있음.
- 소규모-소규모: 결합 대상 테이블이 작은 경우에는 어떤 알고리즘을 사용해도 성능 차이가 크지 않음
- 소규모-대규모: 소규모 테이블을 구동 테이블로 하는 Nested Loops를 사용
- 대규모-대규모: 일단은 Hash를 사용하되, 결합 키로 처음부터 정렬이 되어있는 상태라면 Sort Merge를 사용
> 일단은 Nested Loops, 잘 안되면 Hash의 순서

2. 실행 계획 제어
- 사용자가 실행 계획을 제어할 수 있다.
- Oracle: 힌트 구로 결합 알고리즘 지정 / 구동 테이블 지정
- SQL Server: 힌트 구로 결합 알고리즘 지정
- MySQL: 결합 알고리즘 자체가 Nested Loops 계열밖에 없음

3. 흔들리는 실행 계획
- 장기적인 운용 중에 실행 계획이 안좋은 방향으로 변화해버리는 '옵티마이저의 실패' 발생 가능
- 데이터양의 증가 등에 따라 통계 정보가 변했을 때, 일정한 역치를 넘으면 옵티마이저가 실행 계획을 변화시키며 일어나게 됨.
- 사전에 예측하기 어렵고 돌발적인 슬로다운을 일으킴.
- SQL 성능의 변동 위험을 줄이려면 되도록 결합을 피해야 함. 책의 후반부에서 다룰 예정